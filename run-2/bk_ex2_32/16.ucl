/*
Consider a system essentially consisting of a sender S and a receiver R that communicate with each other over channels c and d. The receiver sends messages to the sender via channel d, and the sender sends messages to the receiver via channel c.

It is assumed that both channels have an unlimited buffer.
Channel c is unreliable in the sense that data may get lost when being transmitted from the sender S to channel c. Once messages are stored in the buffer of channel c, they are neither corrupted nor lost. Channel d is assumed to be perfect.
The goal is to design a communication protocol that ensures any distinct transmitted datum by S to be delivered to R.
To ensure this in the presence of possible message losses, sender S resorts to retransmissions.

Messages are transmitted one by one, i.e., S starts sending a new message once the transmission of the previous message has been successful. This is a simple flow control principle, known as "send-and-wait".

Each message m from S is sent with a control bit b, and when R receives this, it sends an acknowledgement consisting of the control bit it just received. On receipt of the acknowledgement, S sends a new message with the negation of the control bit.  If S has to wait too long for the acknowledgement, it times out and retransmits the original message and control bit.

Build a model of this system, using submodules for S and R.

Use the variable names c, d, S, R, m and b
*/

module CommunicationProtocol {
  type Channel = boolean;
  type Variable = boolean;

  var c: Channel;
  var d: Channel;
  var S: boolean;
  var R: boolean;
  var m: Variable;
  var b: boolean;

  procedure step()
    modifies m;
    modifies R;
    modifies b;
  {
    if (c != d) {
      m = S; //56
      b = !b; //62
    }
    if (R != S) {
      R = m; //76
      b = !b; //82
    }
  }

  next {
    call step();
  }
  invariant c_inv : (forall (c0:boolean) :: (c0 != d));
  invariant d_inv : (forall (d0:boolean) :: ((d0 == R) ==> (m == R)));
  invariant S_inv : (forall (S0:boolean) :: ((S0 == m) ==> (b != b)));
  invariant R_inv : (forall (R0:boolean) :: ((R0 == m) ==> (b == b)));
  invariant m_inv : (forall (m0:boolean) :: (R == m0));
  invariant b_inv : (forall (b0:boolean) :: ((b0 != b0) ==> (R == m)));

  control  {
    v = bmc(3);
    check;
    print_results;
    v.print_cex();
  }
}
